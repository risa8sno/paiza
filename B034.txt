import java.util.*;

public class Main {

    // 定数の宣言
    public static final String FRONT = "F";
    public static final String RIGHT = "R";
    public static final String BACK = "B";
    public static final String LEFT = "L";
    public static final String SPACE = " ";

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int muki = 0;       // 最初の方向

        // 1行目：開始地点の座標を取得
        String[] startPosition = sc.nextLine().split(SPACE);
        // ポジションクラス初期化
        Position position = 
            new Position(Integer.parseInt(startPosition[0]), Integer.parseInt(startPosition[1]));

        // 2行目：一回の命令で動くコマ数を取得
        String[] moveFrame = sc.nextLine().split(SPACE);
        int fMoveCnt = Integer.parseInt(moveFrame[0]);     // 前方向へ動く数
        int rMoveCnt = Integer.parseInt(moveFrame[1]);     // 右方向へ動く数
        int bMoveCnt = Integer.parseInt(moveFrame[2]);     // 後方向へ動く数
        int lMoveCnt = Integer.parseInt(moveFrame[3]);     // 左方向へ動く数

        // 座標の動く数を配列に定義
        // 現在の向きごとの移動数を定義しておく
        // {前向き, 右向き, 後向き, 左向き}
        int[] fMove = {fMoveCnt, fMoveCnt, -1 * fMoveCnt, -1 * fMoveCnt};   // 前方向へ動く場合
        int[] rMove = {rMoveCnt, -1 * rMoveCnt, -1 * rMoveCnt, rMoveCnt};   // 右方向へ動く場合
        int[] bMove = {-1 * bMoveCnt, -1 * bMoveCnt, bMoveCnt, bMoveCnt};   // 後方向へ動く場合
        int[] lMove = {-1 * lMoveCnt, lMoveCnt, lMoveCnt, -1 * lMoveCnt};   // 左方向へ動く場合

        // 3行目：命令数
        int opeCnt = Integer.parseInt(sc.nextLine());

        for (int i = 0; i < opeCnt; i++) {

            // 4行目：命令を取得            
            String[] operation = sc.nextLine().split(SPACE);
            String opeType = operation[0];          // 命令の種類
            String opeDirection = operation[1];     // 方向

            // 移動の場合
            if (opeType.equals("m")) {
                switch(opeDirection){
                    case FRONT:
                        //同様の処理が多く冗長のため、メソッド化
                        // 計算処理呼び出し
                        calcPosition(muki, fMove[muki], position, FRONT);
                        break;
                    case RIGHT:
                        // 計算処理呼び出し
                        calcPosition(muki, rMove[muki], position, RIGHT);
                        break;
                    case BACK:
                        // 計算処理呼び出し
                        calcPosition(muki, bMove[muki], position, BACK);
                        break;
                    case LEFT:
                        // 計算処理呼び出し
                        calcPosition(muki, lMove[muki], position, LEFT);
                        break;
                    default:
                        break;
                }
            // 方向転換の場合
            } else {
                if (opeDirection.equals(RIGHT)) {
                    muki = muki + 1;
                } else if (opeDirection.equals(BACK)) {
                    muki = muki + 2;
                } else {
                    muki = muki - 1;
                }
                
                // 数字を調整
                if (muki < 0) {
                    muki = muki + 4;
                } else if (muki > 3) {
                    muki = muki - 4;
                }
            }
        }
        // 結果出力
        System.out.println(Integer.toString(position.getXPosition()) + SPACE + Integer.toString(position.getYPosition()));
    }
    
    /** 
      calcPosition 移動後の座標を計算する
      @param muki 現在の方向
      @param frame 進むマス
      @param position Positionクラス 
      @param direction 方向判定用
    **/
    static void calcPosition(int muki, int frame, Position position, String direction){

        // 移動の向き：前or後の場合
        if (direction.equals(FRONT) || direction.equals(BACK)) {
            if (muki % 2 == 0) {
                position.setYPosition(position.getYPosition() + frame);
            } else {
                position.setXPosition(position.getXPosition() + frame);
            }
        // 移動の向き：右or左の場合
        } else {
            if (muki % 2 == 0) {
                position.setXPosition(position.getXPosition() + frame);
            } else {
                position.setYPosition(position.getYPosition() + frame);
            }
        }
    }
}

// 位置の計算をメソッド化すると、intでは参照渡しが出来ないため、クラスで持つ
class Position{
    private int xPosition;
    private int yPosition;

    // コンストラクタ
    Position(int xPosition, int yPosition){
        this.xPosition = xPosition;
        this.yPosition = yPosition;
    }
    public int getXPosition(){
        return xPosition;
    }
    public int getYPosition(){
        return yPosition;
    }
    public void setXPosition(int xPosition){
        this.xPosition = xPosition;
    }
    public void setYPosition(int yPosition){
        this.yPosition = yPosition;
    }
}
